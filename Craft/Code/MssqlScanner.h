#ifndef SYTELINE_CRAFT_CODE_MSSQLSCANNER_H
#define SYTELINE_CRAFT_CODE_MSSQLSCANNER_H

#ifndef SYTELINE_CRAFT_CODE_SQLDECLARATION_H
#include "Craft/Code/SqlDeclaration.h"
#endif
#ifndef SYTELINE_CRAFT_CODE_SQLPROCEDURE_H
#include "Craft/Code/SqlProcedure.h"
#endif
#ifndef SYTELINE_CRAFT_CODE_SQLVARIABLE_H
#include "Craft/Code/SqlVariable.h"
#endif
#ifndef SYTELINE_CRAFT_CODE_SQLARGUMENT_H
#include "Craft/Code/SqlArgument.h"
#endif
#ifndef SYTELINE_CRAFT_CODE_MSSQLCAPTURER_H
#include "Craft/Code/MssqlCapturer.h"
#endif

using namespace SyteLine::Craft::Code;

#ifndef YY_DECL

#define	YY_DECL \
    int SyteLine::Craft::Code::CMssqlScanner::Flex(CMssqlCapturer* pCapturer)
#endif

#ifndef __FLEX_LEXER_H
#define yyFlexLexer CMssqlScannerFlexLexer
#include "FlexLexer.h"
#undef yyFlexLexer
#endif

namespace SyteLine { namespace Craft { namespace Code 
{
    class SYTELINE_LIBRARY_EXPORT CMssqlScanner : public CMssqlScannerFlexLexer
    {
    public:
        enum EStage
        {
            E_STAGE_BODY,
            E_STAGE_PRCEDURE_DECLARATION,
            E_STAGE_FUNCTION_DECLARATION
        };

    protected:
        EStage m_eStage;

        CSqlDeclaration m_oDeclaration;
        TSqlProcedure m_oProcedure;
        CSqlVariable m_oVariable;
        CSqlArgument m_oArgument;

        size_t m_nStartingCommentLine;
        size_t m_nEndingCommentLine;
        int m_nLastStatus;

    public:
        /** Create a new scanner object. The streams arg_yyin and arg_yyout default
        * to cin and cout, but that assignment is only made when initializing in
        * yylex(). */
        CMssqlScanner(istream* pYYIn = 0, ostream* pYYOut = 0);

        /** Required for virtual functions */
        virtual ~CMssqlScanner();

        /** This is the main lexing function. It is generated by flex according to
        * the macro declaration YY_DECL above. The generated bison parser then
        * calls this virtual function to fetch new tokens. */
        virtual int Flex(CMssqlCapturer* pCapturer);

    };
}}}

#endif
